目录结构（c:\Users\tassili\Downloads\SMA CPP\SMA-CPP）
├── code_description.txt
├── include
│   ├── bank
│   │   ├── Bank.h
│   │   ├── Cashier.h
│   │   └── Queue.h
│   ├── client
│   │   ├── AbstractClient.hpp
│   │   ├── AbstractOperation.hpp
│   │   ├── Client.hpp
│   │   ├── Consultation.hpp
│   │   ├── Transfer.hpp
│   │   ├── VIPClient.hpp
│   │   └── Withdraw.hpp
│   └── simulation
│       ├── Simulation.h
│       ├── SimulationEntry.h
│       ├── SimulationUtility.h
│       └── StatisticManager.h
├── read.py
└── src
    ├── bank
    │   ├── Bank.cpp
    │   ├── Cashier.cpp
    │   └── Queue.cpp
    ├── client
    │   ├── AbstractClient.cpp
    │   ├── AbstractOperation.cpp
    │   ├── Client.cpp
    │   ├── Consultation.cpp
    │   ├── Transfer.cpp
    │   ├── VIPClient.cpp
    │   └── Withdraw.cpp
    └── simulation
        ├── Simulation.cpp
        ├── SimulationEntry.cpp
        ├── SimulationUtility.cpp
        ├── StatisticManager.cpp
        ├── TestSimulation.cpp
        └── include
            ├── Simulation.h
            ├── SimulationEntry.h
            ├── SimulationUtility.h
            └── StatisticManager.h


文件内容如下：

===== 文件: c:\Users\tassili\Downloads\SMA CPP\SMA-CPP\code_description.txt =====


===== 文件: c:\Users\tassili\Downloads\SMA CPP\SMA-CPP\read.py =====
import os

# 设置目标目录为当前目录
target_dir = os.getcwd()

# 设置输出文件路径
output_file = os.path.join(target_dir, "code_description.txt")

# 要排除的目录名集合（不包含路径）
EXCLUDE_DIRS = {'.git', '__pycache__', '.ipynb_checkpoints'}

def generate_directory_tree(start_path, prefix=''):
    tree_lines = []
    files = sorted(os.listdir(start_path))
    for index, name in enumerate(files):
        if name in EXCLUDE_DIRS:
            continue  # 跳过无关目录
        path = os.path.join(start_path, name)
        connector = '└── ' if index == len(files) - 1 else '├── '
        tree_lines.append(f"{prefix}{connector}{name}")
        if os.path.isdir(path):
            extension = '    ' if index == len(files) - 1 else '│   '
            tree_lines.extend(generate_directory_tree(path, prefix + extension))
    return tree_lines

with open(output_file, 'w', encoding='utf-8') as out_f:
    # 1️⃣ 写入目录结构
    out_f.write(f"目录结构（{target_dir}）\n")
    tree_output = generate_directory_tree(target_dir)
    for line in tree_output:
        out_f.write(line + '\n')

    out_f.write("\n\n文件内容如下：\n")

    # 2️⃣ 写入每个 .py / .md / .sh / dockerfile / .txt 文件内容（排除 EXCLUDE_DIRS）
    for root, dirs, files in os.walk(target_dir):
        # 修改 dirs 以原地排除不需要遍历的目录（重要）
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        for file in files:
            if file.endswith((".py", ".sh", ".md", ".txt")) or file == "dockerfile":
                file_path = os.path.join(root, file)
                out_f.write(f"\n===== 文件: {file_path} =====\n")
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        out_f.write(content + "\n")
                except Exception as e:
                    out_f.write(f"读取失败: {e}\n")

print(f"✅ 所有内容已写入：{output_file}")

